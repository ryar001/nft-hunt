import * as lp from 'it-length-prefixed';
import type { Duplex } from 'it-stream-types';
import type { Uint8ArrayList } from 'uint8arraylist';
interface Decoder<T> {
    (data: Uint8Array | Uint8ArrayList): T;
}
interface Encoder<T> {
    (data: T): Uint8Array;
}
export interface ProtobufStream {
    read: (bytes?: number) => Promise<Uint8ArrayList>;
    readLP: () => Promise<Uint8ArrayList>;
    readPB: <T>(proto: {
        decode: Decoder<T>;
    }) => Promise<T>;
    write: (input: Uint8Array | Uint8ArrayList) => void;
    writeLP: (input: Uint8Array | Uint8ArrayList) => void;
    writePB: (data: Uint8Array | Uint8ArrayList, proto: {
        encode: Encoder<any>;
    }) => void;
    pb: <T>(proto: {
        encode: Encoder<T>;
        decode: Decoder<T>;
    }) => {
        read: () => Promise<T>;
        write: (d: Uint8Array | Uint8ArrayList) => void;
    };
    unwrap: () => Duplex<Uint8ArrayList, Uint8Array>;
}
export interface Opts {
    poolSize: number;
    minPoolSize: number;
    lengthEncoder: lp.LengthEncoderFunction;
    lengthDecoder: lp.LengthDecoderFunction;
    maxLengthLength: number;
    maxDataLength: number;
}
export declare function pbStream(duplex: Duplex<Uint8Array>, opts?: {}): ProtobufStream;
export {};
//# sourceMappingURL=index.d.ts.map