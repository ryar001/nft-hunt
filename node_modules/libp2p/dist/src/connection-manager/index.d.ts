import { SummaryObject } from './latency-monitor.js';
import type { AbortOptions } from '@libp2p/interfaces';
import { EventEmitter } from '@libp2p/interfaces/events';
import type { Startable } from '@libp2p/interfaces/startable';
import { PeerId } from '@libp2p/interface-peer-id';
import type { Connection, MultiaddrConnection } from '@libp2p/interface-connection';
import type { ConnectionManager } from '@libp2p/interface-connection-manager';
import { Components, Initializable } from '@libp2p/components';
import type { AddressSorter } from '@libp2p/interface-peer-store';
import type { Resolver } from '@multiformats/multiaddr';
export interface ConnectionManagerInit {
    /**
     * The maximum number of connections to keep open
     */
    maxConnections: number;
    /**
     * The minimum number of connections to keep open
     */
    minConnections: number;
    /**
     * The max data (in and out), per average interval to allow
     */
    maxData?: number;
    /**
     * The max outgoing data, per average interval to allow
     */
    maxSentData?: number;
    /**
     * The max incoming data, per average interval to allow
     */
    maxReceivedData?: number;
    /**
     * The upper limit the event loop can take to run
     */
    maxEventLoopDelay?: number;
    /**
     * How often, in milliseconds, metrics and latency should be checked
     */
    pollInterval?: number;
    /**
     * How often, in milliseconds, to compute averages
     */
    movingAverageInterval?: number;
    /**
     * If true, try to connect to all discovered peers up to the connection manager limit
     */
    autoDial?: boolean;
    /**
     * How long to wait between attempting to keep our number of concurrent connections
     * above minConnections
     */
    autoDialInterval: number;
    /**
     * Sort the known addresses of a peer before trying to dial
     */
    addressSorter?: AddressSorter;
    /**
     * Number of max concurrent dials
     */
    maxParallelDials?: number;
    /**
     * Number of max addresses to dial for a given peer
     */
    maxAddrsToDial?: number;
    /**
     * How long a dial attempt is allowed to take, including DNS resolution
     * of the multiaddr, opening a socket and upgrading it to a Connection.
     */
    dialTimeout?: number;
    /**
     * When a new inbound connection is opened, the upgrade process (e.g. protect,
     * encrypt, multiplex etc) must complete within this number of ms.
     */
    inboundUpgradeTimeout: number;
    /**
     * Number of max concurrent dials per peer
     */
    maxDialsPerPeer?: number;
    /**
     * Multiaddr resolvers to use when dialing
     */
    resolvers?: Record<string, Resolver>;
    /**
     * On startup we try to dial any peer that has previously been
     * tagged with KEEP_ALIVE up to this timeout in ms. (default: 60000)
     */
    startupReconnectTimeout?: number;
}
export interface ConnectionManagerEvents {
    'peer:connect': CustomEvent<PeerId>;
    'peer:disconnect': CustomEvent<PeerId>;
}
/**
 * Responsible for managing known connections.
 */
export declare class DefaultConnectionManager extends EventEmitter<ConnectionManagerEvents> implements ConnectionManager, Startable, Initializable {
    private components;
    private readonly opts;
    private readonly connections;
    private started;
    private timer?;
    private readonly latencyMonitor;
    private readonly startupReconnectTimeout;
    private connectOnStartupController?;
    private readonly dialTimeout;
    constructor(init: ConnectionManagerInit);
    init(components: Components): void;
    isStarted(): boolean;
    /**
     * Starts the Connection Manager. If Metrics are not enabled on libp2p
     * only event loop and connection limits will be monitored.
     */
    start(): Promise<void>;
    afterStart(): Promise<void>;
    beforeStop(): Promise<void>;
    /**
     * Stops the Connection Manager
     */
    stop(): Promise<void>;
    /**
     * Cleans up the connections
     */
    _close(): Promise<void>;
    /**
     * Checks the libp2p metrics to determine if any values have exceeded
     * the configured maximums.
     *
     * @private
     */
    _checkMetrics(): Promise<void>;
    onConnect(evt: CustomEvent<Connection>): void;
    /**
     * Tracks the incoming connection and check the connection limit
     */
    _onConnect(evt: CustomEvent<Connection>): Promise<void>;
    /**
     * Removes the connection from tracking
     */
    onDisconnect(evt: CustomEvent<Connection>): void;
    getConnections(peerId?: PeerId): Connection[];
    openConnection(peerId: PeerId, options?: AbortOptions): Promise<Connection>;
    closeConnections(peerId: PeerId): Promise<void>;
    /**
     * Get all open connections with a peer
     */
    getAll(peerId: PeerId): Connection[];
    /**
     * If the event loop is slow, maybe close a connection
     */
    _onLatencyMeasure(evt: CustomEvent<SummaryObject>): void;
    /**
     * If the `value` of `name` has exceeded its limit, maybe close a connection
     */
    _checkMaxLimit(name: keyof ConnectionManagerInit, value: number, toPrune?: number): Promise<void>;
    /**
     * If we have more connections than our maximum, select some excess connections
     * to prune based on peer value
     */
    _maybePruneConnections(toPrune: number): Promise<void>;
    acceptIncomingConnection(maConn: MultiaddrConnection): Promise<boolean>;
}
//# sourceMappingURL=index.d.ts.map