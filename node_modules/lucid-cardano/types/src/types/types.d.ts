import { Core } from "../core/mod.js";
import { Constr } from "../plutus/mod.js";
declare type CostModel = Record<string, number>;
export declare type CostModels = Record<ScriptType, CostModel>;
export declare type ProtocolParameters = {
    minFeeA: number;
    minFeeB: number;
    maxTxSize: number;
    maxValSize: number;
    keyDeposit: bigint;
    poolDeposit: bigint;
    priceMem: number;
    priceStep: number;
    maxTxExMem: bigint;
    maxTxExSteps: bigint;
    coinsPerUtxoByte: bigint;
    collateralPercentage: number;
    maxCollateralInputs: number;
    costModels: CostModels;
};
export declare type Slot = number;
export interface Provider {
    getProtocolParameters(): Promise<ProtocolParameters>;
    getUtxos(address: Address): Promise<UTxO[]>;
    getUtxosWithUnit(address: Address, unit: Unit): Promise<UTxO[]>;
    getUtxosByOutRef(outRefs: Array<OutRef>): Promise<UTxO[]>;
    getDelegation(rewardAddress: RewardAddress): Promise<Delegation>;
    getDatum(datumHash: DatumHash): Promise<Datum>;
    awaitTx(txHash: TxHash): Promise<boolean>;
    submitTx(tx: Transaction): Promise<TxHash>;
}
export declare type Credential = {
    type: "Key" | "Script";
    hash: KeyHash | ScriptHash;
};
/** Concatenation of policy id and asset name in Hex */
export declare type Unit = string;
export declare type Assets = Record<string, bigint>;
export declare type ScriptType = "Native" | "PlutusV1" | "PlutusV2";
/** Hex */
export declare type PolicyId = string;
/**
 * Plutus scripts need to be double Cbor encoded.
 * Raw compiled scripts without any Cbor encoding do not work.
 */
export declare type Script = {
    type: ScriptType;
    script: string;
};
/**
 * Plutus scripts need to be double Cbor encoded.
 * Raw compiled scripts without any Cbor encoding do not work.
 */
export declare type Validator = MintingPolicy | SpendingValidator | CertificateValidator | WithdrawalValidator;
/**
 * Plutus scripts need to be double Cbor encoded.
 * Raw compiled scripts without any Cbor encoding do not work.
 */
export declare type MintingPolicy = Script;
/**
 * Plutus scripts need to be double Cbor encoded.
 * Raw compiled scripts without any Cbor encoding do not work.
 */
export declare type SpendingValidator = Script;
/**
 * Plutus scripts need to be double Cbor encoded.
 * Raw compiled scripts without any Cbor encoding do not work.
 */
export declare type CertificateValidator = Script;
/**
 * Plutus scripts need to be double Cbor encoded.
 * Raw compiled scripts without any Cbor encoding do not work.
 */
export declare type WithdrawalValidator = Script;
/** Bech32 */
export declare type Address = string;
/** Bech32 */
export declare type RewardAddress = string;
/** Hex */
export declare type PaymentKeyHash = string;
/** Hex */
export declare type StakeKeyHash = string;
/** Hex */
export declare type KeyHash = string | PaymentKeyHash | StakeKeyHash;
/** Hex */
export declare type VrfKeyHash = string;
/** Hex */
export declare type ScriptHash = string;
/** Hex */
export declare type TxHash = string;
/** Bech32 */
export declare type PoolId = string;
/** Hex */
export declare type Datum = string;
/**
 * asHash will add the datum hash to the output and the datum to the witness set.
 * inline will add the datum to the output.
 * scriptRef will add any script to the output.
 * You can only specify asHash or inline, not both at the same time.
 */
export declare type OutputData = {
    asHash?: Datum;
    inline?: Datum;
    scriptRef?: Script;
};
/** Hex */
export declare type DatumHash = string;
/** Hex (Redeemer is only PlutusData, same as Datum) */
export declare type Redeemer = string;
export declare type Lovelace = bigint;
export declare type Label = number;
/** Hex */
export declare type TransactionWitnesses = string;
/** Hex */
export declare type Transaction = string;
/** Bech32 */
export declare type PrivateKey = string;
/** Hex */
export declare type ScriptRef = string;
/** Hex */
export declare type Payload = string;
export declare type UTxO = {
    txHash: TxHash;
    outputIndex: number;
    assets: Assets;
    address: Address;
    datumHash?: DatumHash;
    datum?: Datum;
    scriptRef?: ScriptRef;
};
export declare type OutRef = {
    txHash: TxHash;
    outputIndex: number;
};
export declare type AddressType = "Base" | "Enterprise" | "Pointer" | "Reward";
export declare type Network = "Mainnet" | "Testnet" | "Preview" | "Preprod";
export declare type AddressDetails = {
    type: AddressType;
    networkId: number;
    address: {
        bech32: Address;
        hex: string;
    };
    paymentCredential?: Credential;
    stakeCredential?: Credential;
};
export declare type Delegation = {
    poolId: PoolId | null;
    rewards: Lovelace;
};
/**
 * A wallet that can be constructed from external data e.g utxos and an address.
 * It doesn't allow you to sign transactions/messages. This needs to be handled separately.
 */
export interface ExternalWallet {
    address: Address;
    utxos?: UTxO[];
    rewardAddress?: RewardAddress;
}
export declare type SignedMessage = {
    signature: string;
    key: string;
};
export interface Wallet {
    address(): Promise<Address>;
    rewardAddress(): Promise<RewardAddress | null>;
    getUtxos(): Promise<UTxO[]>;
    getUtxosCore(): Promise<Core.TransactionUnspentOutputs>;
    getDelegation(): Promise<Delegation>;
    signTx(tx: Core.Transaction): Promise<Core.TransactionWitnessSet>;
    signMessage(address: Address | RewardAddress, payload: Payload): Promise<SignedMessage>;
    submitTx(signedTx: Transaction): Promise<TxHash>;
}
/**
 * These are the arguments that conform a BuiltinData in Plutus:
 * data Data =
 *   Constr Integer [Data]
 * | Map [(Data, Data)]
 * | List [Data]
 * | I Integer
 * | B BS.ByteString
 *   deriving stock (Show, Eq, Ord, Generic)
 *   deriving anyclass (NFData)
 */
export declare type PlutusData = bigint | Bytes | Array<PlutusData> | Map<PlutusData, PlutusData> | Constr<PlutusData>;
/** Hex in case of string. */
declare type Bytes = string | Uint8Array;
/** JSON object */
export declare type Json = any;
/** Time in milliseconds */
export declare type UnixTime = number;
declare type NFTFile = {
    name: string;
    mediaType: string;
    src: string | string[];
};
export declare type NFTMetadataDetails = {
    name: string;
    image: string;
    mediaType?: string;
    description?: string | string[];
    files?: NFTFile[];
    [key: string]: unknown;
};
export declare type PoolParams = {
    poolId: PoolId;
    vrfKeyHash: VrfKeyHash;
    pledge: Lovelace;
    cost: Lovelace;
    margin: number;
    rewardAddress: RewardAddress;
    owners: Array<RewardAddress>;
    relays: Array<Relay>;
    metadataUrl?: string;
};
export declare type Relay = {
    type: "SingleHostIp" | "SingleHostDomainName" | "MultiHost";
    ipV4?: string;
    ipV6?: string;
    port?: number;
    domainName?: string;
};
export declare type NativeScript = {
    type: "sig" | "all" | "any" | "before" | "atLeast" | "after";
    keyHash?: KeyHash;
    required?: number;
    slot?: Slot;
    scripts?: NativeScript[];
};
export declare type SlotConfig = {
    zeroTime: UnixTime;
    zeroSlot: Slot;
    slotLength: number;
};
export {};
