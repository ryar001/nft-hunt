import { decode, decodeString, encodeToString, } from "../../deps/deno.land/std@0.100.0/encoding/hex.js";
import { C } from "../core/mod.js";
import { generateMnemonic } from "../misc/bip39.js";
import { SLOT_CONFIG_NETWORK, slotToBeginUnixTime, unixTimeToEnclosingSlot, } from "../plutus/time.js";
export class Utils {
    constructor(lucid) {
        Object.defineProperty(this, "lucid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.lucid = lucid;
    }
    validatorToAddress(validator, stakeCredential) {
        const validatorHash = this.validatorToScriptHash(validator);
        if (stakeCredential) {
            return C.BaseAddress.new(networkToId(this.lucid.network), C.StakeCredential.from_scripthash(C.ScriptHash.from_hex(validatorHash)), stakeCredential.type === "Key"
                ? C.StakeCredential.from_keyhash(C.Ed25519KeyHash.from_hex(stakeCredential.hash))
                : C.StakeCredential.from_scripthash(C.ScriptHash.from_hex(stakeCredential.hash)))
                .to_address()
                .to_bech32(undefined);
        }
        else {
            return C.EnterpriseAddress.new(networkToId(this.lucid.network), C.StakeCredential.from_scripthash(C.ScriptHash.from_hex(validatorHash)))
                .to_address()
                .to_bech32(undefined);
        }
    }
    credentialToAddress(paymentCredential, stakeCredential) {
        if (stakeCredential) {
            return C.BaseAddress.new(networkToId(this.lucid.network), paymentCredential.type === "Key"
                ? C.StakeCredential.from_keyhash(C.Ed25519KeyHash.from_hex(paymentCredential.hash))
                : C.StakeCredential.from_scripthash(C.ScriptHash.from_hex(paymentCredential.hash)), stakeCredential.type === "Key"
                ? C.StakeCredential.from_keyhash(C.Ed25519KeyHash.from_hex(stakeCredential.hash))
                : C.StakeCredential.from_scripthash(C.ScriptHash.from_hex(stakeCredential.hash)))
                .to_address()
                .to_bech32(undefined);
        }
        else {
            return C.EnterpriseAddress.new(networkToId(this.lucid.network), paymentCredential.type === "Key"
                ? C.StakeCredential.from_keyhash(C.Ed25519KeyHash.from_hex(paymentCredential.hash))
                : C.StakeCredential.from_scripthash(C.ScriptHash.from_hex(paymentCredential.hash)))
                .to_address()
                .to_bech32(undefined);
        }
    }
    validatorToRewardAddress(validator) {
        const validatorHash = this.validatorToScriptHash(validator);
        return C.RewardAddress.new(networkToId(this.lucid.network), C.StakeCredential.from_scripthash(C.ScriptHash.from_hex(validatorHash)))
            .to_address()
            .to_bech32(undefined);
    }
    credentialToRewardAddress(stakeCredential) {
        return C.RewardAddress.new(networkToId(this.lucid.network), stakeCredential.type === "Key"
            ? C.StakeCredential.from_keyhash(C.Ed25519KeyHash.from_hex(stakeCredential.hash))
            : C.StakeCredential.from_scripthash(C.ScriptHash.from_hex(stakeCredential.hash)))
            .to_address()
            .to_bech32(undefined);
    }
    validatorToScriptHash(validator) {
        if (validator.type === "Native") {
            return C.NativeScript.from_bytes(fromHex(validator.script))
                .hash(C.ScriptHashNamespace.NativeScript)
                .to_hex();
        }
        else if (validator.type === "PlutusV1") {
            return C.PlutusScript.from_bytes(fromHex(validator.script))
                .hash(C.ScriptHashNamespace.PlutusV1)
                .to_hex();
        }
        else if (validator.type === "PlutusV2") {
            return C.PlutusScript.from_bytes(fromHex(validator.script))
                .hash(C.ScriptHashNamespace.PlutusV2)
                .to_hex();
        }
        throw new Error("No variant matched");
    }
    mintingPolicyToId(mintingPolicy) {
        return this.validatorToScriptHash(mintingPolicy);
    }
    datumToHash(datum) {
        return C.hash_plutus_data(C.PlutusData.from_bytes(fromHex(datum))).to_hex();
    }
    scriptHashToCredential(scriptHash) {
        return {
            type: "Script",
            hash: scriptHash,
        };
    }
    keyHashToCredential(keyHash) {
        return {
            type: "Key",
            hash: keyHash,
        };
    }
    generatePrivateKey() {
        return C.PrivateKey.generate_ed25519().to_bech32();
    }
    generateSeedPhrase() {
        return generateMnemonic(256);
    }
    unixTimeToSlot(unixTime) {
        return unixTimeToEnclosingSlot(unixTime, SLOT_CONFIG_NETWORK[this.lucid.network]);
    }
    slotToUnixTime(slot) {
        return slotToBeginUnixTime(slot, SLOT_CONFIG_NETWORK[this.lucid.network]);
    }
    /** Address can be in Bech32 or Hex */
    getAddressDetails(address) {
        return getAddressDetails(address);
    }
    /**
     * Convert a native script from Json to the Hex representation.
     * It follows this Json format: https://github.com/input-output-hk/cardano-node/blob/master/doc/reference/simple-scripts.md
     */
    nativeScriptFromJson(nativeScript) {
        return nativeScriptFromJson(nativeScript);
    }
}
function addressFromHexOrBech32(address) {
    try {
        return C.Address.from_bytes(fromHex(address));
    }
    catch (_e) {
        try {
            return C.Address.from_bech32(address);
        }
        catch (_e) {
            throw new Error("Could not deserialize address.");
        }
    }
}
/** Address can be in Bech32 or Hex */
export function getAddressDetails(address) {
    // Base Address
    try {
        const parsedAddress = C.BaseAddress.from_address(addressFromHexOrBech32(address));
        const paymentCredential = parsedAddress.payment_cred().kind() === 0
            ? {
                type: "Key",
                hash: toHex(parsedAddress.payment_cred().to_keyhash().to_bytes()),
            }
            : {
                type: "Script",
                hash: toHex(parsedAddress.payment_cred().to_scripthash().to_bytes()),
            };
        const stakeCredential = parsedAddress.stake_cred().kind() === 0
            ? {
                type: "Key",
                hash: toHex(parsedAddress.stake_cred().to_keyhash().to_bytes()),
            }
            : {
                type: "Script",
                hash: toHex(parsedAddress.stake_cred().to_scripthash().to_bytes()),
            };
        return {
            type: "Base",
            networkId: parsedAddress.to_address().network_id(),
            address: {
                bech32: parsedAddress.to_address().to_bech32(undefined),
                hex: toHex(parsedAddress.to_address().to_bytes()),
            },
            paymentCredential,
            stakeCredential,
        };
    }
    catch (_e) { /* pass */ }
    // Enterprise Address
    try {
        const parsedAddress = C.EnterpriseAddress.from_address(addressFromHexOrBech32(address));
        const paymentCredential = parsedAddress.payment_cred().kind() === 0
            ? {
                type: "Key",
                hash: toHex(parsedAddress.payment_cred().to_keyhash().to_bytes()),
            }
            : {
                type: "Script",
                hash: toHex(parsedAddress.payment_cred().to_scripthash().to_bytes()),
            };
        return {
            type: "Enterprise",
            networkId: parsedAddress.to_address().network_id(),
            address: {
                bech32: parsedAddress.to_address().to_bech32(undefined),
                hex: toHex(parsedAddress.to_address().to_bytes()),
            },
            paymentCredential,
        };
    }
    catch (_e) { /* pass */ }
    // Pointer Address
    try {
        const parsedAddress = C.PointerAddress.from_address(addressFromHexOrBech32(address));
        const paymentCredential = parsedAddress.payment_cred().kind() === 0
            ? {
                type: "Key",
                hash: toHex(parsedAddress.payment_cred().to_keyhash().to_bytes()),
            }
            : {
                type: "Script",
                hash: toHex(parsedAddress.payment_cred().to_scripthash().to_bytes()),
            };
        return {
            type: "Pointer",
            networkId: parsedAddress.to_address().network_id(),
            address: {
                bech32: parsedAddress.to_address().to_bech32(undefined),
                hex: toHex(parsedAddress.to_address().to_bytes()),
            },
            paymentCredential,
        };
    }
    catch (_e) { /* pass */ }
    // Reward Address
    try {
        const parsedAddress = C.RewardAddress.from_address(addressFromHexOrBech32(address));
        const stakeCredential = parsedAddress.payment_cred().kind() === 0
            ? {
                type: "Key",
                hash: toHex(parsedAddress.payment_cred().to_keyhash().to_bytes()),
            }
            : {
                type: "Script",
                hash: toHex(parsedAddress.payment_cred().to_scripthash().to_bytes()),
            };
        return {
            type: "Reward",
            networkId: parsedAddress.to_address().network_id(),
            address: {
                bech32: parsedAddress.to_address().to_bech32(undefined),
                hex: toHex(parsedAddress.to_address().to_bytes()),
            },
            stakeCredential,
        };
    }
    catch (_e) { /* pass */ }
    throw new Error("No address type matched for: " + address);
}
export function valueToAssets(value) {
    const assets = {};
    assets["lovelace"] = BigInt(value.coin().to_str());
    const ma = value.multiasset();
    if (ma) {
        const multiAssets = ma.keys();
        for (let j = 0; j < multiAssets.len(); j++) {
            const policy = multiAssets.get(j);
            const policyAssets = ma.get(policy);
            const assetNames = policyAssets.keys();
            for (let k = 0; k < assetNames.len(); k++) {
                const policyAsset = assetNames.get(k);
                const quantity = policyAssets.get(policyAsset);
                const unit = toHex(policy.to_bytes()) + toHex(policyAsset.name());
                assets[unit] = BigInt(quantity.to_str());
            }
        }
    }
    return assets;
}
export function assetsToValue(assets) {
    const multiAsset = C.MultiAsset.new();
    const lovelace = assets["lovelace"];
    const units = Object.keys(assets);
    const policies = Array.from(new Set(units
        .filter((unit) => unit !== "lovelace")
        .map((unit) => unit.slice(0, 56))));
    policies.forEach((policy) => {
        const policyUnits = units.filter((unit) => unit.slice(0, 56) === policy);
        const assetsValue = C.Assets.new();
        policyUnits.forEach((unit) => {
            assetsValue.insert(C.AssetName.new(fromHex(unit.slice(56))), C.BigNum.from_str(assets[unit].toString()));
        });
        multiAsset.insert(C.ScriptHash.from_bytes(fromHex(policy)), assetsValue);
    });
    const value = C.Value.new(C.BigNum.from_str(lovelace ? lovelace.toString() : "0"));
    if (units.length > 1 || !lovelace)
        value.set_multiasset(multiAsset);
    return value;
}
export function utxoToCore(utxo) {
    const address = (() => {
        try {
            return C.Address.from_bech32(utxo.address);
        }
        catch (_e) {
            return C.ByronAddress.from_base58(utxo.address).to_address();
        }
    })();
    const output = C.TransactionOutput.new(address, assetsToValue(utxo.assets));
    if (utxo.datumHash) {
        output.set_datum(C.Datum.new_data_hash(C.DataHash.from_bytes(fromHex(utxo.datumHash))));
    }
    // inline datum
    if (!utxo.datumHash && utxo.datum) {
        output.set_datum(C.Datum.new_data(C.Data.new(C.PlutusData.from_bytes(fromHex(utxo.datum)))));
    }
    if (utxo.scriptRef) {
        output.set_script_ref(C.ScriptRef.from_bytes(fromHex(utxo.scriptRef)));
    }
    return C.TransactionUnspentOutput.new(C.TransactionInput.new(C.TransactionHash.from_bytes(fromHex(utxo.txHash)), C.BigNum.from_str(utxo.outputIndex.toString())), output);
}
export function coreToUtxo(coreUtxo) {
    return {
        txHash: toHex(coreUtxo.input().transaction_id().to_bytes()),
        outputIndex: parseInt(coreUtxo.input().index().to_str()),
        assets: valueToAssets(coreUtxo.output().amount()),
        address: coreUtxo.output().address().as_byron()
            ? coreUtxo.output().address().as_byron()?.to_base58()
            : coreUtxo.output().address().to_bech32(undefined),
        datumHash: coreUtxo.output()?.datum()?.as_data_hash()?.to_hex(),
        datum: coreUtxo.output()?.datum()?.as_data() &&
            toHex(coreUtxo.output().datum().as_data().to_bytes()),
        scriptRef: coreUtxo.output()?.script_ref() &&
            toHex(coreUtxo.output().script_ref().to_bytes()),
    };
}
export function networkToId(network) {
    switch (network) {
        case "Testnet":
            return 0;
        case "Preview":
            return 0;
        case "Preprod":
            return 0;
        case "Mainnet":
            return 1;
        default:
            throw new Error("Network not found");
    }
}
export function fromHex(hex) {
    return decodeString(hex);
}
export function toHex(bytes) {
    return encodeToString(bytes);
}
export function hexToUtf8(hex) {
    return new TextDecoder().decode(decode(new TextEncoder().encode(hex)));
}
export function utf8ToHex(utf8) {
    return toHex(new TextEncoder().encode(utf8));
}
// WIP!! This is not finalized yet until CIP-0067 and CIP-0068 are merged
function checksum(num) {
    return num.toString(16).split("").reduce((acc, curr) => acc + parseInt(curr, 16), 0x0)
        .toString(16).padStart(2, "0");
}
export function toLabel(num) {
    if (num < 0 || num > 65535) {
        throw new Error(`Label ${num} out of range: min label 0 - max label 65535.`);
    }
    return "0" + num.toString(16).padStart(4, "0") + checksum(num) +
        "0";
}
export function fromLabel(label) {
    if (label.length !== 8 || !(label[0] === "0" && label[7] === "0")) {
        return null;
    }
    const num = parseInt(label.slice(1, 5), 16);
    const check = label.slice(5, 7);
    return check === checksum(num) ? num : null;
}
/**
 * @param name UTF-8 encoded
 */
export function toUnit(policyId, name, label) {
    const hexLabel = Number.isInteger(label) ? toLabel(label) : "";
    const hexName = name ? toHex(new TextEncoder().encode(name)) : "";
    if ((hexName + hexLabel).length > 64) {
        throw new Error("Asset name size exceeds 32 bytes.");
    }
    if (policyId.length !== 56) {
        throw new Error(`Policy Id invalid: ${policyId}.`);
    }
    return policyId + hexLabel + hexName;
}
/**
 * Splits unit into policy id, name and label if applicable.
 * name will be returned in UTF-8 if possible, otherwise in Hex.
 */
export function fromUnit(unit) {
    const policyId = unit.slice(0, 56);
    const label = fromLabel(unit.slice(56, 64));
    const name = (() => {
        const hexName = Number.isInteger(label) ? unit.slice(64) : unit.slice(56);
        if (!hexName)
            return null;
        try {
            return hexToUtf8(hexName);
        }
        catch (_e) {
            return hexName;
        }
    })();
    return { policyId, name, label };
}
/**
 * Convert a native script from Json to the Hex representation.
 * It follows this Json format: https://github.com/input-output-hk/cardano-node/blob/master/doc/reference/simple-scripts.md
 */
export function nativeScriptFromJson(nativeScript) {
    return {
        type: "Native",
        script: toHex(C.encode_json_str_to_native_script(JSON.stringify(nativeScript), "", C.ScriptSchema.Node).to_bytes()),
    };
}
