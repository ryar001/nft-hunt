import{L as Y,B as f,b as h,E as R,A as k,f as D,T as q,h as H,i as L,k as K,C as M,l as $,m as G,S as J,n as Q,o as P,p as z,r as X,j as Z,a as x,e as _,R as W}from"./jsx-runtime.41f56b82.js";const ee="/assets/someDude.0037f1c9.png";class w extends Error{constructor(a){super(a)}}class O extends w{constructor(a){super(a)}}class o extends w{constructor(a){super(a)}}class m extends o{constructor(a){super(a)}}class C extends m{constructor(a){super(a)}}class v extends m{constructor(a){super(a)}}class T extends m{constructor(a){super(a)}}class ae extends m{constructor(a){super(a)}}class ne extends m{constructor(a){super(a)}}class g extends m{constructor(a){super(a)}}class E extends m{constructor(a){super(a)}}let V=!1;class e{static _api_key=void 0;static _protocolParameters=void 0;static _namiObj=void 0;static _namiInterface=void 0;static _NamiWallet=void 0;static _eternlObj=void 0;static _eternlInterface=void 0;static _EternlWallet=void 0;static _flintObj=void 0;static _flintInterface=void 0;static _flintWallet=void 0;static _yoroiObj=void 0;static _yoroiInterface=void 0;static _yoroiWallet=void 0;static _geroObj=void 0;static _geroInterface=void 0;static _geroWallet=void 0;static _typhonObj=void 0;static _typhonInterface=void 0;static _TyphonWallet=void 0;static _cardWalletObj=void 0;static _cardWalletInterface=void 0;static _CardWalletWallet=void 0;static _assertBrowser(){if(typeof window>"u")throw new w("can check for any cardano wallet extension only in a browser environment")}static Names=Object.freeze({Nami:"Nami",CCVault:"ccvault",Eternl:"eternl",Flint:"Flint Wallet",Yoroi:"yoroi",Gero:"GeroWallet",Typhon:"Typhon Wallet",Cardwallet:"CardWallet"});static stringNames=Object.freeze(Object.keys(e.Names).map(a=>{if(a!==e.Names.CCVault)return e.Names[a]}).filter(a=>a!==void 0));static utils={getStringFromWalletName:e._getStringFromWalletName,getWalletNameFromString:e._getWalletNameFromString};static _getStringFromWalletName(a){const t=new w("walletNameEnum must be a property of the Wallet.Names enum object");if(!e.stringNames.includes(a))throw t;return a}static _getWalletNameFromString(a){const t=new w("getWalletNameFromString parameter must be a valid wallet string name");if(typeof a!="string"||!e.stringNames.includes(a))throw t;return a}static setBlockfrost(a){if(typeof a!="string")throw new O("blockfrost_project_id must be a string");e._api_key=a,V=!0}static async makeBlockfrostRequest(a,t,c){if(!V)throw new o("Wallet.setBlockfrost has not been called, can't use Wallet.makeBlockfrostRequest");return await F(e._api_key,a)}static hasProtocolParameters(){return e._protocolParameters!==void 0}static async getProtocolParameters(a=void 0){if(!e.hasProtocolParameters()){let t="";if(typeof a=="string")t=a;else{if(!V)throw new o("Wallet.setBlockfrost has not been called, can't use Wallet.getProtocolParameters");t=e._api_key}e._protocolParameters=await te(t)}return e._protocolParameters}static get protocolParameters(){if(!e.hasProtocolParameters())throw new m("protocolParameters never checked before, call the async version Wallet.getProtocolParameters first");return e._protocolParameters}static _assertWalletNameIsValid(a){if(typeof a!="string")throw new o("a wallet identifier should be a member of the ```Wallet.Names``` enumeration");if(!e.stringNames.includes(a))throw new o("a wallet identifier should be a member of the ```Wallet.Names``` enumeration")}static _assertWalletExtensionInjected(a){if(e._assertWalletNameIsValid(a),!e.has(a))throw new m("can't access the "+a+" object if the "+a+" extension is not installed")}static has(a){switch(e._assertBrowser(),e._assertWalletNameIsValid(a),a){case e.Names.Nami:return!!window?.cardano?.nami;case e.Names.CCVault:case e.Names.Eternl:return!!window?.cardano?.eternl;case e.Names.Flint:return!!window?.cardano?.flint;case e.Names.Yoroi:return!!window?.cardano?.yoroi;case e.Names.Gero:return!!window?.cardano?.gerowallet;case e.Names.Typhon:return!!window?.cardano?.typhon;case e.Names.Cardwallet:return!!window?.cardano?.cardwallet;default:throw new o("invalid argument; wallet name should be a member of the WalleName enumeration object")}}static get(a){switch(e._assertBrowser(),e._assertWalletNameIsValid(a),a){case e.Names.Nami:return e.Nami;case e.Names.CCVault:case e.Names.Eternl:return e.CCVault;case e.Names.Flint:return e.Flint;case e.Names.Yoroi:return e.Yoroi;case e.Names.Gero:return e.Gero;case e.Names.Typhon:return e.Typhon;case e.Names.Cardwallet:return e.Cardwallet;default:throw new o("invalid argument; wallet name should be a member of the WalleName enumeration object")}}static getInterface(a){if(e._assertBrowser(),e._assertWalletNameIsValid(a),a===e.Names.Nami)return e.NamiInterface;if(a=e.Names.Eternl||a===e.Names.CCVault)return e.CCVaultInterface;if(a===e.Names.Flint)return e.FlintInterface;if(a===e.Names.Gero)return e.GeroInterface;if(a===e.Names.Typhon)return e.TyphonInterface;if(a===e.Names.Yoroi)return e.YoroiInterface;if(a===e.Names.Cardwallet)return e.CardwalletInterface;throw new o("invalid argument; wallet name should be a member of the Wallet.Names enumeration object")}static async enable(a){switch(e._assertWalletExtensionInjected(a),a){case e.Names.Nami:e._namiObj=await window.cardano.nami.enable();return;case e.Names.CCVault:case e.Names.Eternl:e._eternlObj=await window.cardano.eternl.enable();return;case e.Names.Flint:e._flintObj=await window.cardano.flint.enable();return;case e.Names.Yoroi:e._yoroiObj=await window.cardano.yoroi.enable();return;case e.Names.Gero:e._geroObj=await window.cardano.gerowallet.enable();return;case e.Names.Typhon:if((await window.cardano.typhon.enable()).status)e._typhonObj=window.cardano.typhon;else throw new g("user rejected typhon connection");return;case e.Names.Cardwallet:e._cardWalletObj=await window.cardano.cardwallet.enable();return;default:throw new o("invalid argument; wallet name should be a member of the WalleName enumeration object")}}static async isEnabled(a){e._assertWalletExtensionInjected(a);let t=!1;switch(a){case e.Names.Nami:t=await window.cardano.nami.isEnabled();break;case e.Names.CCVault:t=await window.cardano.eternl.isEnabled();break;case e.Names.Flint:t=await window.cardano.flint.isEnabled();break;case e.Names.Yoroi:t=await window.cardano.yoroi.isEnabled();break;case e.Names.Gero:t=await window.cardano.gerowallet.isEnabled();break;case e.Names.Typhon:let{status:c,data:i}=await window.cardano.typhon.isEnabled();t=i&&c;break;case e.Names.Cardwallet:t=await window.cardano.cardwallet.isEnabled();break;default:throw new o("invalid argument; wallet name should be a member of the WalleName enumeration object")}return t?(await e.enable(a),!0):!1}static isAviable(a){switch(e._assertWalletNameIsValid(a),a){case e.Names.Nami:return e._namiObj!==void 0;case e.Names.CCVault:return e._eternlObj!==void 0;case e.Names.Flint:return e._flintObj!==void 0;case e.Names.Yoroi:return e._yoroiObj!==void 0;case e.Names.Gero:return e._geroObj!==void 0;case e.Names.Typhon:return e._typhonObj!==void 0;case e.Names.Cardwallet:return e._cardWalletObj!==void 0;default:throw new o("invalid argument; wallet name should be a member of the WalleName enumeration object")}}static get NamiInterface(){if(!e.has(e.Names.Nami))throw new C("can't access the nami object if the nami extension is not installed");return e._namiInterface===void 0&&(e._namiInterface=p(e.Names.Nami)),e._namiInterface}static get Nami(){if(!e.has(e.Names.Nami))throw new C("can't access the Nami object if the nami extension is not installed");if(!e.isAviable(e.Names.Nami))throw new C("Wallet.enableNami has never been called before, can't access the Nami wallet object");return e._NamiWallet===void 0&&(e._NamiWallet=b(e._namiObj,e._api_key)),e._NamiWallet}static get CCVaultInterface(){return e.EternlInterface}static get EternlInterface(){if(!e.has(e.Names.CCVault)||!e.has(e.Names.Eternl))throw new v("can't access the ccvault object if the ccvault extension is not installed");return e._eternlInterface===void 0&&(e._eternlInterface=p(e.Names.CCVault)),e._eternlInterface}static get CCVault(){return e.Eternl}static get Eternl(){if(!e.has(e.Names.CCVault)||!e.has(e.Names.Eternl))throw new v("can't access the CCVault object if the CCVault extension is not installed");if(!e.isAviable(e.Names.CCVault)||!e.isAviable(e.Names.Eternl))throw new v("Wallet.enableCCVault has never been called before, can't access the CCVault wallet object");return e._EternlWallet===void 0&&(e._EternlWallet=b(e._eternlObj,e._api_key)),e._EternlWallet}static get FlintInterface(){if(!e.has(e.Names.Flint))throw new T("can't access the flint object if the flint extension is not installed");return e._flintInterface===void 0&&(e._flintInterface=p(e.Names.Flint)),e._flintInterface}static get Flint(){if(!e.has(e.Names.Flint))throw new T("can't access the flint object if the flint extension is not installed");if(!e.isAviable(e.Names.Flint))throw new T("Wallet.enableFlint has never been called before, can't access the flint wallet object");return e._flintWallet===void 0&&(e._flintWallet=b(e._flintWallet,e._api_key)),e._flintWallet}static get YoroiInterface(){if(!e.has(e.Names.Yoroi))throw new ae("can't access the yoroi object if the yoroi extension is not installed");return e._yoroiInterface===void 0&&(e._yoroiInterface=p(e.Names.Yoroi)),e._yoroiInterface}static get Yoroi(){if(!e.has(e.Names.Yoroi))throw new w("can't access the Yoroi object if the Yoroi nigthly extension is not installed");if(!e.isAviable(e.Names.Yoroi))throw new w("Wallet.enableYoroi has never been called before, can't access the Yoroi interface");return e._yoroiWallet===void 0&&(e._yoroiWallet=b(e._yoroiObj,e._api_key)),e._yoroiWallet}static get GeroInterface(){if(!e.has(e.Names.Gero))throw new ne("can't access the gero object if the gerowallet extension is not installed");return e._geroInterface===void 0&&(e._geroInterface=p(e.Names.Gero)),e._geroInterface}static get Gero(){if(!e.has(e.Names.Gero))throw new w("can't access the Gero object if the Gero Wallet extension is not installed");if(!e.isAviable(e.Names.Gero))throw new w("Wallet.enableGero has never been called before, can't access the Gero interface");return e._geroWallet===void 0&&(e._geroWallet=b(e._geroObj,e._api_key)),e._geroWallet}static get TyphonInterface(){if(!e.has(e.Names.Typhon))throw new g("can't access the Typhon object if the Typhon extension is not installed");return e._typhonInterface===void 0&&(e._typhonInterface=p(e.Names.Typhon)),e._typhonInterface}static get Typhon(){if(!e.has(e.Names.Typhon))throw new g("can't access the Typhon object if the Typhon Wallet extension is not installed");if(!e.isAviable(e.Names.Typhon))throw new g("Wallet.enable( Wallet.Names.Typhon ) has never been called before, can't access the Typhon interface");return e._TyphonWallet===void 0&&(e._TyphonWallet=b(e._typhonObj,e._api_key)),e._TyphonWallet}static get CardwalletInterface(){if(!e.has(e.Names.Cardwallet))throw new E("can't access the Cardwallet object if the Cardwallet extension is not installed");return e._cardWalletInterface===void 0&&(e._cardWalletInterface=p(e.Names.Cardwallet)),e._cardWalletInterface}static get Cardwallet(){if(!e.has(e.Names.Cardwallet))throw new E("can't access the Cardwallet object if the Cardwallet Wallet extension is not installed");if(!e.isAviable(e.Names.Cardwallet))throw new E("Wallet.enable( Wallet.Names.Cardwallet ) has never been called before, can't access the Cardwallet interface");return e._CardWalletWallet===void 0&&(e._CardWalletWallet=b(e._cardWalletObj,e._api_key)),e._CardWalletWallet}}function p(n){e._assertBrowser(),e._assertWalletNameIsValid(n);function a(){switch(n){case e.Names.Nami:return window?.cardano?.nami?.apiVersion?window.cardano.nami.apiVersion:"";case e.Names.CCVault:case e.Names.Eternl:return window?.cardano?.eternl?.apiVersion?window.cardano.eternl.apiVersion:"";case e.Names.Flint:return window?.cardano?.flint?.apiVersion?window.cardano.flint.apiVersion:"";case e.Names.Yoroi:return window?.cardano?.yoroi?.apiVersion?window.cardano.yoroi.apiVersion:"";case e.Names.Gero:return window?.cardano?.gerowallet?.apiVersion?window.cardano.gerowallet.apiVersion:"";case e.Names.Typhon:return window?.cardano?.typhon?.apiVersion?window.cardano.typhon.apiVersion:"";case e.Names.Cardwallet:return window?.cardano?.cardwallet?.apiVersion?window.cardano.cardwallet.apiVersion:"";default:throw new o("invalid argument; wallet name should be a member of the WalleName enumeration object")}}function t(){switch(n){case e.Names.Nami:return window?.cardano?.nami?.name?window.cardano.nami.name:"";case e.Names.CCVault:case e.Names.Eternl:return window?.cardano?.eternl?.name?window.cardano.eternl.name:"";case e.Names.Flint:return window?.cardano?.flint?.name?window.cardano.flint.name:"";case e.Names.Yoroi:return window?.cardano?.yoroi?.name?window.cardano.yoroi.name:"";case e.Names.Gero:return window?.cardano?.gerowallet?.name?window.cardano.gerowallet.name:"";case e.Names.Typhon:return window?.cardano?.typhon?.name?window.cardano.typhon.name:"";case e.Names.Cardwallet:return window?.cardano?.cardwallet?.name?window.cardano.cardwallet.name:"";default:throw new o("invalid argument; wallet name should be a member of the WalleName enumeration object")}}function c(){switch(n){case e.Names.Nami:return window?.cardano?.nami?.icon?window.cardano.nami.icon:"";case e.Names.CCVault:case e.Names.Eternl:return window?.cardano?.eternl?.icon?window.cardano.eternl.icon:"";case e.Names.Flint:return window?.cardano?.flint?.icon?window.cardano.flint.icon:"";case e.Names.Yoroi:return window?.cardano?.yoroi?.icon?window.cardano.yoroi.icon:"";case e.Names.Gero:return window?.cardano?.gerowallet?.icon?window.cardano.gerowallet.icon:"";case e.Names.Typhon:return window?.cardano?.typhon?.icon?window.cardano.typhon.icon:"";case e.Names.Cardwallet:return window?.cardano?.cardwallet?.icon?window.cardano.cardwallet.icon:"";default:throw new o("invalid argument; wallet name should be a member of the WalleName enumeration object")}}return{apiVersion:a(),icon:c(),name:t(),isInjected:()=>e.has(n),isAviable:()=>e.isAviable(n),isEnabled:()=>e.isEnabled(n),enable:()=>e.enable(n)}}function b(n,a){const t=async(r=void 0)=>{if(!(r||a))throw new C("no blockfrost api key was provvided, please set a default one by calling Wallet.setBlockfrost or pass one as a parameter");if(typeof r!="string"){if(typeof a!="string")throw new C("no blockfrost api key is valid");return await S(n,a)}else return await S(n,r)},c=async(r,l=void 0)=>{if(typeof r!="string")throw new O("in order to delegate to a pool you must provvide a valid pool id string;  pool id was: "+r);if(!r.startsWith("pool"))throw new O("you must use the bech 32 pool id, perhaps you provvided the hex pool id? input was: "+r);if(n.name==="Typhon Wallet"){const{status:s,data:N}=await window.cardano.typhon.delegationTransaction({poolId:r});if(s===!0)return N.transactionId;throw new g("delegation transaction rejected")}return await se(l,n,await t(l),r)},i=async r=>await oe(n,r),u=async r=>await ie(n,r);return{raw:n,getCurrentUserDelegation:t,createDelegagtionTransaction:c,signTransaction:i,submitTransaction:u,signAndSubmitTransaction:async r=>await u(await i(r)),getPoolId:re,delegateTo:async(r,l=void 0)=>await u(await i(await c(r,l)))}}async function F(n,a,t,c){if(typeof n!="string")throw Error;return await fetch("https://cardano-mainnet.blockfrost.io/api/v0"+a,{headers:{project_id:n}}).then(i=>i.json())}async function te(n){if(typeof n!="string")throw Error;const a=await F(n,"/epochs/latest/parameters");return{linearFee:Y.new(f.from_str(a.min_fee_a.toString()),f.from_str(a.min_fee_b.toString())),minUtxo:f.from_str(a.min_utxo),poolDeposit:f.from_str(a.pool_deposit),keyDeposit:f.from_str(a.key_deposit),maxValueSize:a.max_val_size,maxTxSize:a.max_tx_size}}function re(n){return h.Buffer.from(R.from_bech32(n).to_bytes(),"hex").toString("hex")}async function U(n){const a=n.getRewardAddress||n.getRewardAddresses;if(typeof a!="function")throw new o("could not find reward address or addresses, probably this is not your fault and the package may need mainatainance,     please open an issue at https://github.com/HarmonicPool/cardano-wallet-interface/issues");let t=await a();if(Array.isArray(t)?t=t[0]:typeof t=="object"&&(t=t.data),typeof t!="string")throw new o("bad request for getting user reward address, probably not your fault, pleas open an issue explaining what appened here: https://github.com/HarmonicPool/cardano-wallet-interface/issues");return t}async function se(n,a,t,c){const i=await fetch("https://cardano-mainnet.blockfrost.io/api/v0/epochs/latest/parameters",{headers:{project_id:n}}).then(y=>y.json());let u=(await a.getUsedAddresses())[0];if(u===void 0)throw new o("Seems like the user has no used addresses, please found the using wallet");u=k.from_bytes(h.Buffer.from(u,"hex"));const A=await U(a),I=D.from_address(k.from_bytes(h.Buffer.from(A,"hex"))).payment_cred();let r=await a.getUtxos();r=r.map(y=>q.from_bytes(h.Buffer.from(y,"hex")));const l=H.new();r.forEach(y=>l.add(y));let s=L.new();s=s.coins_per_utxo_word(f.from_str(i.coins_per_utxo_word)),s=s.fee_algo(Y.new(f.from_str(i.min_fee_a.toString()),f.from_str(i.min_fee_b.toString()))),s=s.key_deposit(f.from_str(i.key_deposit)),s=s.pool_deposit(f.from_str(i.pool_deposit)),s=s.max_tx_size(parseInt(i.max_tx_size)),s=s.max_value_size(parseInt(i.max_val_size)),s=s.prefer_pure_change(!0),s=s.build();const N=K.new(s);N.add_inputs_from(l,M.RandomImprove);const j=$.new();t.active||j.add(G.new_stake_registration(J.new(I))),j.add(G.new_stake_delegation(Q.new(I,R.from_bech32(c)))),N.set_certs(j),N.add_change_if_needed(u);const B=P.new(N.build(),z.new());if(B.to_bytes().length*2>i.maxTxSize)throw ERROR.txTooBig;return B}async function oe(n,a){return await P.new(a.body(),z.from_bytes(h.Buffer.from(await n.signTx(h.Buffer.from(a.to_bytes(),"hex").toString("hex")),"hex")))}async function ie(n,a){return await n.submitTx(h.Buffer.from(a.to_bytes(),"hex").toString("hex"))}async function ce(n){return await k.from_bytes(h.Buffer.from(await U(n),"hex")).to_bech32()}async function S(n,a){const t=await ce(n),c=await F(a,`/accounts/${t}`);return!c||c.error||!c.pool_id?{}:c}const d=e;async function de(){d.getInterface(d.Names.Typhon);const n=d.getInterface(d.Names.CCVault);for(let a=0;a<d.stringNames.length;a++)console.log(d.stringNames[a]),console.log(d.has(d.stringNames[a]));n.isInjected()?n.isAviable()&&d.CCVault:(await n.isEnabled()||await d.enable(d.Names.CCVault),d.CCVault)}function fe(){return X.exports.useState(0),Z("div",{className:"App_sp",children:[x("img",{src:ee}),x("button",{onClick:de})]})}_.createRoot(document.getElementById("root")).render(x(W.StrictMode,{children:x(fe,{})}));
